---
title: 计算数组的逆序数对
---
#计算数组的逆序数对
## 1、	问题描述设A[1,….n]是一个包含n个不同非负整数的数组。若果i<j的情况下，有A[i]>A[j]，则（A[i],A[j]）就称为A中的一个逆序对。请设计一个时间复杂度不超过O(n*log2n)的算法并编程实现，统计任意长度的数组A中全部逆序对的个数。## 2、	算法设计思想可以使用分治法解决此问题。设计思想如下：利用归并排序的拓展可以解决该问题，只是在归并排序合并的基础上加上常数级别的对逆序数对的统计，即可得到逆序数对的结果。所以时间复杂度与归并排序相同为O(n*log2n)。归并排序是将要排序的n个数划分成两个一样的规模为n / 2的子问题，一直划分直到达到递归的边界条件（start < end）的时候进行归并，在归并的时候，因为被划分为A和B数组，如果前数组A有某个元素大于B上的某个元素，则A上该元素后面位置的元素均比B上该位置的元素大，为逆序数对加上A后面所有元素的个数。等到最后合并完也得到了逆序数对的个数。## 3、	算法过程描述找出数组[6 2 7 3 1]的逆序数对。（1）	将数组进行划分，划分成[6 2 7],[3 1]，再继续划分，[6,2] ,[7],[6 , 2 ]还为有序继续划分称为[6],[2].（2）	求解子问题：[6]和[2]要合并之前得到一个逆序数对，合并完有序，跟[7]进行合并，没有逆序数对。将[3 , 1]划分称为[3],[1]，合并有一个逆序数对。（3）	合并子问题得出最后结果，将[2,6,7]，[1,3]合并。1比2小，有三个逆序数对，记录下来，合并后[1,2]，3比6小，有两个逆序数对[3,6],[3,7]，记录下来，并结果合并，得到最后结果逆序数对7个。在归并的过程中可以将逆序数对全部记录到。## 4、	算法实现及运行结果(语言：c++)```
#include <iostream>using namespace std;int result = 0; // 用于记录逆序数对//归并void merge(int num[],int start,int middle,int end){	//开始合并找到的两个有序子序列	//暂存空间	int temp[end - start + 1];	int k = 0;	int i = start;	int j = middle + 1;	while(i <= middle && j <= end){		if(num[i] < num[j]){			temp[k++] = num[i++];		}		else{			result += middle - i + 1;//num[i] 大于num[j] ，因为前半部分有序，则num[i]后面的数均大于num[j]			temp[k++] = num[j++];		}	}	//合并将某一个组剩下的有序元素均复制到暂存空间中	while(i <= middle){		temp[k++] = num[i++];	}	while(j <= end){		temp[k++] = num[j++];	}	//放回num数组中使之有序，使后面后面继续归并	for(int index = 0 ; index < k; index++){		num[start + index] = temp[index];	}}//归并排序void mergeSort(int num[],int start,int end){	if(start < end){//递归条件		int middle = (start + end) / 2;		//进行递归分解成子问题		mergeSort(num, start, middle);		mergeSort(num,middle + 1, end);		merge(num,start,middle,end);	}}int main() {	int n;	cout << "输入数组的长度：";	cin >> n;	cout << "输入" << n << "个不同的正整数:";	int num[n];	for(int i = 0;i < n;i++){		cin >> num[i];	}	mergeSort(num,0,n - 1);	cout << "逆序数对个数为 : " << result;}```运行结果如下：## 5、	算法复杂度分析及算法改进###（1）	时间复杂度当n=1时，没有逆序数对无需进行任何操作返回0，所以时间复杂度为O(1)，当n>1时将问题规模为n的问题划分成为规模为n/2的问题然后，因为两个数组分别有序，所以合并过程中可以直接得到逆序数对，时间复杂度也为常数，而将两个部分合并起来所需要的时间为O(n)，所以时间复杂度如下：
![](media/15073825835103/15073836249921.jpg)
解递归方程得到T(n)=O(nlog2n)###（2）	空间复杂度需要n个辅助空间来暂存合并结果，所以空间复杂度为S(n) = O(n)###（3）算法改进
改变子问题规模是否会提升算法时间复杂度。


**如有勘误留言在评论进行修改。**

